# 时间复杂度

## 简单介绍

时间复杂度是一个算法在输入大小增加时运行时间的增长率。

它是一个函数，表示随着输入数据的增加，算法需要多少步操作来完成任务。

## 符号表示

时间复杂度通常使用大O表示法(O-notation)，这是一种表示算法的运行时间随输入规模变化的数学记号。

常见的时间复杂度有：

- $\Omicron(1)$ 
  
  常数时间复杂度：算法的执行时间不随输入大小的变化而变化。
  
  例如：访问数组中的某一个元素

- $\Omicron(\log \Nu)$  
  
  对数时间复杂度：算法的执行时间随着输入大小的增大而以对数方式增长。
  
  例如：二分法查找算法

- $\Omicron(\Nu)$
  
  线性时间复杂度：算法的执行时间与输入数据大小成线性比例。
  
  例如：使用`for`循环遍历数组

- $\Omicron(\Nu \log \Nu)$

  线性对数时间复杂度：算法的执行时间是输入大小N和log N的乘积。

- $\Omicron(\Nu ^ {2})$

  平方时间复杂度：算法的运行时间与输入大小的平方成正比。
  
  例如：嵌套的`for`循环

- $\Omicron(2 ^ {\Nu})$
 
  指数时间复杂度：算法的运行时间随着输入大小呈指数增长。

- $\Omicron(\Nu!)$

  阶乘时间复杂度：算法的运行时间随着输入大小的阶乘增长。

## 简单例子

以下是一个简单的冒泡排序算法在`C++`中的体现

```cpp
void bubbleSort(int arr[], int n) {
    for (int i = 0; i < n-1; ++i) {
        for (int j = 0; j < n-i-1; ++j) {
            if (arr[j] > arr[j+1]) {
                swap(arr[j], arr[j+1]);
            }
        }
    }
}
```

这个算法的最好结果是 $\Omicron(\Nu)$ ， 即数组已经排序完成，仅需要遍历即可； 最坏的结果是 $\Omicron(\Nu ^ {2})$ ， 即数组完全相反，需要完成双层`for`循环。

## 实际应用

通过时间复杂度我们可以做到如下几点：

- 完成性能评估：
  
  在一些复杂场景下，可以帮助我们理解和评估算法的性能。

- 选择合适的算法：

  在程序设计阶段，通过比较时间复杂度，可以帮助我们选择最合适的算法。